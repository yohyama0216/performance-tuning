# SQLのクエリの最適化
SQLのクエリの最適化はデータベースドリブンのWebサイトやアプリケーションにおいて、パフォーマンスの改善に非常に重要です。クエリが効率的でない場合、データベースサーバーに不必要な負荷がかかり、結果としてWebサイトのレスポンスタイムが遅くなる可能性があります。

## スロークエリの特定
遅いクエリを特定するための設定を行う。

### スロークエリログの設定
#### スロークエリログの有効化
MySQL設定ファイル（通常は my.cnf または my.ini）を編集して、スロークエリログを有効にします。
```[mysqld]
slow_query_log = 1
slow_query_log_file = /var/log/mysql/mysql-slow.log
long_query_time = 2
```
* slow_query_log = 1: スロークエリログを有効にします。
* slow_query_log_file = /var/log/mysql/mysql-slow.log: スロークエリログのファイルを /var/log/mysql/mysql-slow.log に設定しています。
* long_query_time = 2: 2秒以上かかるクエリをスロークエリとして記録します。
#### ログファイルの指定
スロークエリログの出力先となるファイルを指定します。
#### スロークエリの閾値設定
「スロー」と見なされるクエリの実行時間の閾値を設定します。この時間を超えるクエリがログに記録されます。
#### MySQLの再起動
設定を反映させるためにMySQLサーバーを再起動します。

## EXPLAINで分析
基本的な構文は非常にシンプルです。分析したいSELECT、UPDATE、DELETE、INSERT、REPLACEクエリの前にEXPLAINキーワードを付けます。
例: EXPLAIN SELECT * FROM your_table;
結果の読み取り:

EXPLAINの結果には、複数の列が含まれています。これらは、クエリがどのように実行されるかに関する情報を提供します。重要な列にはid, select_type, table, type, possible_keys, key, key_len, ref, rows, Extraなどがあります。
例
以下に、EXPLAINコマンドを使用した具体的な例を示します。

例1: 単純なSELECTクエリ

クエリ:

sql
Copy code
SELECT name, age FROM users WHERE age > 25;
EXPLAIN使用:

sql
Copy code
EXPLAIN SELECT name, age FROM users WHERE age > 25;
例2: JOINを含むクエリ

クエリ:

sql
Copy code
SELECT u.name, o.order_date FROM users u JOIN orders o ON u.id = o.user_id WHERE u.age > 25;
EXPLAIN使用:

sql
Copy code
EXPLAIN SELECT u.name, o.order_date FROM users u JOIN orders o ON u.id = o.user_id WHERE u.age > 25;
結果の解釈
type: クエリがどのようにテーブルをスキャンするかを示します（例: ALLはフルテーブルスキャン、indexはインデックススキャン）。
possible_keys: クエリに使用可能なインデックス。
key: 実際に使用されるインデックス。
rows: クエリ処理においてスキャンされると予想される行数。
Extra: 追加情報、例えば「Using index」はインデックスオンリースキャンを意味します。
EXPLAINコマンドを利用することで、クエリのパフォーマンスを評価し、必要に応じて最適化するための洞察を得ることができます。特に、大量のデータを扱う場合や複雑なクエリを実行する場合に非常に有効です。

MySQLのEXPLAINコマンドの結果を理解するためには、それぞれの列が何を意味しているかを知ることが重要です。ここでは、主要な列とその意味について詳しく解説します。

1. id
意味: クエリ内のSELECT文の識別子。複数のSELECT文がある場合（サブクエリやJOINなど）、それぞれに異なるIDが割り当てられます。
使用法: 複雑なクエリを解析する際に、どのSELECT文がどの順序で実行されるかを理解するのに役立ちます。
2. select_type
意味: クエリの種類。例えば、SIMPLE（単純なSELECT）、PRIMARY（最も外側のSELECT）、SUBQUERY（サブクエリ内のSELECT）などがあります。
使用法: クエリがどのような形で実行されるかを知るのに有用です。
3. table
意味: 参照されるテーブルの名前。
使用法: どのテーブルがクエリのどの部分で使用されているかを把握します。
4. type
意味: JOINの種類またはテーブルアクセス方法。ALL（フルテーブルスキャン）、index（インデックス全スキャン）、range（インデックス範囲スキャン）、ref（非ユニークインデックスを用いた検索）、eq_ref（ユニークインデックスを用いた一致検索）などがあります。
使用法: クエリの効率を判断する上で重要。例えば、ALLは一般的に非効率的です。
5. possible_keys
意味: クエリによって使用される可能性のあるインデックス。
使用法: インデックスの有効性を評価するのに役立ちます。
6. key
意味: 実際にクエリで使用されるインデックス。
使用法: どのインデックスがクエリの実行に利用されているかを把握します。
7. key_len
意味: 使用されるインデックスの長さ（バイト単位）。
使用法: インデックスの特定部分だけが使用されているかどうかを知るのに有用です。
8. ref
意味: インデックスを検索するために使用される列または定数。
使用法: インデックスの検索条件を理解するのに役立ちます。
9. rows
意味: クエリを実行するためにMySQLが読み込む必要があると推定される行数。
使用法: クエリのコストや効率を評価する指標となります。
10. Extra
意味: クエリの追加情報。例えば、Using index（インデックスオンリースキャンを意味する）やUsing temporary（一時テーブルを使用することを意味する）、Using filesort（ソートにファイルシステムを使用することを意味する）などが含まれます。
使用法: クエリの実行方法に関する詳細な洞察を提供します。

EXPLAINコマンドのtypeやExtraで表示される情報の中で、特に注意すべきいくつかの点を挙げます。

Type
ALL（フルテーブルスキャン）:

typeがALLと表示される場合、クエリはテーブルの全行をスキャンしています。これは一般に非効率的で、特に大きなテーブルではパフォーマンスに大きな影響を与える可能性があります。
対策: 適切なインデックスの追加、クエリの書き換え。
index（インデックス全スキャン）:

テーブルの全てのインデックスエントリをスキャンします。ALLよりは効率的ですが、大きなインデックスでは依然としてコストが高い場合があります。
対策: より効率的なインデックスを検討する、クエリを最適化する。
Extra
Using filesort:

MySQLが結果をソートするために追加のパス（しばしばディスクベース）を使用していることを意味します。これは、特に大量のデータに対しては、パフォーマンスに悪影響を及ぼす可能性があります。
対策: クエリの書き換え、適切なインデックスの使用。
Using temporary:

クエリの実行に一時テーブルが使用されていることを意味します。これは、GROUP BYやORDER BY句が複数の列にまたがるときによく発生します。ディスクベースの一時テーブルは特にパフォーマンスに影響します。
対策: クエリの再構築、適切なインデックスの追加。
全般的な考慮事項
パフォーマンスに影響を与える可能性のあるtypeやExtraの値に注意を払い、それらを改善するためにクエリの書き換えやインデックスの見直しを検討してください。
データベースの設定、テーブルのサイズ、インデックスの設計などによって、これらの問題の影響度は異なります。
データベースとアプリケーションの全体的なパフォーマンスを維持するためには、定期的なモニタリングとチューニングが不可欠です。
EXPLAINコマンドは、パフォーマンス問題の診断と解決において非常に有用ですが、その結果の解釈と適切な対応策の選択にはデータベースに関する深い知識が必要です。

## クエリの改善
見つかったクエリの改善を行う

### インデックスの使用
適切なインデックスをテーブルに追加することで、クエリの検索速度を大幅に向上させることができます。

### SELECTステートメントの最適化
- 必要な列のみを選択する。
- JOIN操作を最適化する。
- WHERE句を利用して、必要なレコードのみをフィルタリングする。

### サブクエリよりもJOINを使用
可能な場合、サブクエリよりもJOINを使用することで、パフォーマンスを向上させることができることが多い。
[リンク](./subquery-join.md)
複数のテーブルをJOINする場合、どのテーブルをどの順序でJOINするかがパフォーマンスに大きく影響します。
小さなテーブルから大きなテーブルへのJOIN、またはより多くのフィルター条件を持つテーブルからJOINを始めると、効率が良くなることがあります。

### クエリの再利用
同じクエリを何度も実行する場合、プリペアドステートメントやストアドプロシージャを使用すると、パフォーマンスの向上が期待できます。

### LIMIT句の利用
大量のデータを取得する必要がない場合、LIMIT句を使用して必要なレコード数だけを取得する。

### 統計データの更新
あらかじめ統計的なデータはバッチなどで計算しておく。
データベースの統計データを定期的に更新することで、クエリプランナが最適なクエリプランを選択するのを助けます。

### 正規化の見直し
データベースの正規化は、データの整合性を保つために重要ですが、一部のクエリのパフォーマンスを低下させる可能性もあります。過度な正規化が原因でパフォーマンスが低下している場合、デノーマライゼーションを検討することもあります。
